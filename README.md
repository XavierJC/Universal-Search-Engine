## 系统（问题）描述

本系统旨在解决海量文本数据下的快速检索问题。传统的搜索方式通常采用“顺序扫描法”，即逐个打开文件查找关键词，其时间复杂度随文件数量线性增长，效率低下。本设计实现了一个基于 **倒排索引（Inverted Index）** 技术的“万能搜索器”。系统在启动阶段对指定目录下的所有文本文件（.txt）进行预处理，提取单词并构建索引库。用户输入关键词后，系统能以接近 $O(1)$ 的时间复杂度瞬间定位到包含该词的所有文档，并根据单词出现的频率（词频）对结果进行相关度排序，模拟了现代商业搜索引擎（如 Google、百度）的核心后端逻辑。

## 任务分配

本小组共有5名成员 ，具体分工如下：

- **成员1（组长）：** 负责系统总体架构设计，定义核心数据结构（哈希表与倒排链表），编写 `main` 函数及主菜单逻辑。
- **成员2：** 负责文件 I/O 模块。**实现 `LoadFileAndIndex` 函数，利用 `fopen` 和 `fgets` 动态读取外部 `.txt` 文件流，实现数据与代码的分离。**
- **成员3：** 负责分词与索引构建模块。实现字符串分割算法，处理大小写转换，并将提取的单词插入哈希表。
- **成员4：** 负责核心搜索与排序算法。实现根据关键词查找哈希表，并对搜索结果按“词频”进行降序排序。
- **成员5：** 负责系统界面优化、测试用例编写、以及撰写设计报告中的“总结”与“测试数据”部分。

## 系统需求

**1. 索引构建功能：** 系统启动时，应自动扫描数据源，识别所有有效单词（忽略标点符号），建立“单词 $\rightarrow$ 文档列表”的映射关系。 
**2. 快速检索功能：** 用户输入任意英文单词，系统应立即返回包含该单词的所有文件名。 
**3. 结果排序功能：** 搜索结果不能杂乱无章，必须根据关键词在文档中出现的次数（Term Frequency）进行降序排列，优先展示最相关的文档。 
**4. 健壮性需求：** 系统应支持不区分大小写搜索（如输入 "Apple" 能搜到 "apple"），并能处理哈希冲突。

## 设计思想

本系统的核心设计思想是 **“空间换时间”**。通过预先消耗内存建立索引，避免了每次搜索都进行全盘扫描。

### 数据结构的选择和设计

为了实现毫秒级搜索，本系统放弃了传统的线性表，转而采用 **哈希表（Hash Table）** 结合 **链表（Linked List）** 的结构。
**核心模型：倒排索引 (Inverted Index)**

- **哈希表（主索引）：** 使用一个定长数组 `WordNode* HashTable[SIZE]` 存储所有出现的单词。数组下标由哈希函数计算得出。

- **单词节点（WordNode）：** 存储单词本身，以及指向“文档链表”的指针。

- **文档节点（DocNode）：** 这是一个单链表结构，挂载在单词节点下。每个节点记录了 `doc_id`（文档编号）、`doc_name`（文档名）以及 `count`（该词在文档中出现的次数）。
  **C语言结构体定义如下：**

```c
// 文档节点（链表节点）
typedef struct DocNode {
    int doc_id;             // 文档ID
    char doc_name[50];      // 文档名称
    int count;              // 词频 (权重)
    struct DocNode *next;   // 下一个文档
} DocNode;

// 单词节点（哈希桶中的元素）
typedef struct WordNode {
    char word[30];          // 单词内容
    DocNode *doc_list;      // 倒排索引：指向包含该词的文档链表头
    struct WordNode *next;  // 拉链法：处理哈希冲突
} WordNode;
```

### 算法设计

 **1.哈希算法 (BKDR Hash)：**

为了将字符串均匀映射到数组下标，采用 BKDRHash 算法。该算法利用素数种子（Seed=131）进行迭代计算，能有效减少冲突。

$$Hash(str) = (Hash * Seed + str[i]) \% TableSize$$

**2. 索引插入算法：**

- 读取一个单词 $W$ 和当前文档 $D$。
- 计算 $Index = Hash(W)$。
- 在 `HashTable[Index]` 中查找 $W$：
  - 若 $W$ 不存在：创建新单词节点，并挂载包含 $D$ 的文档节点。
  - 若 $W$ 已存在：遍历其 `doc_list`。
    - 若 $D$ 也在列表中：`count++`。
    - 若 $D$ 不在列表中：创建新文档节点插入链表头部。

**3. 搜索与排序算法：**

- 计算查询词的哈希值，直接定位到哈希桶。
- 遍历桶内链表找到匹配的单词节点。
- 获取该单词的 `doc_list`，遍历链表输出结果。由于链表构建时是动态插入的，输出前可使用简单的冒泡排序或插入排序对 `doc_list` 按 `count` 值进行重排。

### 实现细节说明

**关键算法实现过程：** 系统主要由 `LoadFileAndIndex`（文件加载与索引构建）和 `Search`（搜索）两部分组成。
1. **文件读取与索引构建：** 程序通过 `fopen` 打开外部文件，使用 `fgets` 逐行读取文本内容至内存缓冲区。随后利用 C 语言的 `strtok` 函数按空格和标点符号（`" ,.?!\"\n\t"`）将文本分割为独立单词。
2. **预处理：** 为了实现不区分大小写，在计算哈希值之前，使用 `tolower` 函数将所有字符统一转换为小写。
3. **哈希插入：** 计算单词的 BKDR 哈希值，将其插入到倒排索引结构中。

**操作过程与界面：** 系统采用控制台菜单界面。

1. **初始化：** 程序启动，自动扫描并加载同级目录下的数据文件（如 `source_1.txt` 等），显示 "正在索引文件..."。

2. **搜索交互：** 用户输入 "data"，系统瞬间打印如下表格：

   ```plaintxt
   >>> 搜索结果: "I" 
   >>> [1] source_1.txt (出现 2 次) 
   >>> [2] source_2.txt (出现 22 次)


## 测试数据及测试结果

**测试数据集：** 准备了3个测试文件。

- `a.txt`: "Data structure is important. Data data data." (含4个 "data")
- `b.txt`: "Structure is basic." (不含 "data")
- `c.txt`: "Computer science data." (含1个 "data")

**测试功能与结果：**

1. **测试点：** 关键词搜索与词频统计。
   - **输入：** `data`
   - **预期：** 找到 a.txt 和 c.txt，且 a.txt 排在前面。
   - **实际结果：** 显示 `a.txt (Count: 4)`，然后显示 `c.txt (Count: 1)`。**（符合需求）**
2. **测试点：** 大小写不敏感。
   - **输入：** `DATA`
   - **预期：** 结果与输入 `data` 一致。
   - **实际结果：** 成功识别并返回了相同结果。**（符合需求）**
3. **测试点：** 不存在的词。
   - **输入：** `biology`
   - **实际结果：** 提示 "未找到相关文档"。**（符合需求）**


# 总结

## 系统特点及创新

- **实现了文件数据流分离：** 系统摒弃了硬编码测试数据的方式，支持直接读取外部 `.txt` 文件。通过文件流（File Stream）技术动态加载数据，使得系统具备了处理真实文档的能力，大大增强了实用性。
- **工业级数据结构：** 本系统没有使用简单的数组遍历，而是实现了商业搜索引擎通用的 **倒排索引** 结构 。这使得搜索速度不随文档库的增大而变慢，体现了极高的数据结构设计水平。
- **智能排序：** 实现了基于 **词频（TF - Term Frequency）** 的排序算法，不仅告诉用户“哪里有”，还告诉用户“哪里最相关”，提升了用户体验。
- **哈希冲突处理：** 采用了经典的 **链地址法（Separate Chaining）** 解决哈希冲突，保证了系统的稳定性。
## 遇到的问题及解决思路

- **问题：** 标点符号紧挨单词（如 "hello,"）导致无法正确识别单词。
  - **解决：** 在 `strtok` 分割字符串时，将标点符号集合 `",.?!:;"` 全部作为分隔符参数传入，彻底清洗数据。
- **问题：** 不同的文件路径在不同电脑上无法读取。
  - **解决：** 采用相对路径读取文件，或在代码中定义文件列表数组，确保移植性。
- **问题：** 链表操作中指针容易丢失导致程序崩溃。
  - **解决：** 画出链表插入的逻辑图，严格按照“先连后断”的顺序编写代码，并增加了指针非空判断。
- **问题：** 程序运行时提示“无法打开文件”或读取不到数据。
  - **解决：** 这是由于相对路径问题导致的。在开发环境中，确保 `.txt` 数据文件与源代码文件（或编译后的 `.exe` 可执行文件）放置在**同一个文件夹**内，并检查文件名后缀是否正确（避免出现 `a.txt.txt`）。

**参考文献**
[1] 严蔚敏, 吴伟民. 数据结构(C语言版). 清华大学出版社, 2018. [2] Brian W. Kernighan, Dennis M. Ritchie. C程序设计语言. 机械工业出版社, 2004. [3] 百度百科. 倒排索引技术. [https://baike.baidu.com/item/倒排索引](https://www.google.com/search?q=https://baike.baidu.com/item/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&authuser=1)
